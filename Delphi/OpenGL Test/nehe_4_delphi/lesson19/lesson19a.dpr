program lesson19a;

{   kÛd pro Delphi 7}

uses
  Windows,
  Messages,
  OpenGL, sysutils,
  GLaux;

procedure glGenTextures(n: GLsizei; var textures: GLuint); stdcall; external opengl32;
procedure glBindTexture(target: GLenum; texture: GLuint); stdcall; external opengl32;

type
  particles = record          // Vytvo¯Ì stukturu pro Ë·stici
    active: bool;             // AktivnÌ?
    life: glfloat;            // éivot
    fade: glfloat;            // Rychlost st·rnutÌ
    r, g, b: glfloat;         // Sloûky barvy
    x, y, z: glfloat;         // Pozice
    xi, yi, zi: glfloat;      // SmÏr a rychlost
    xg, yg, zg: glfloat;      // Gravitace
    end;

const
  MAX_PARTICLES = 1000;      // PoËet vytv·¯en˝ch Ë·stic

var
  h_Rc: HGLRC;		                  // Trval˝ Rendering Context
  h_Dc: HDC;                        // Priv·tnÌ GDI Device Context
  h_Wnd: HWND;                      // Obsahuje Handle naöeho okna
  keys: array [0..255] of BOOL;	    // Pole pro ukl·d·nÌ vstupu z kl·vesnice
  Active: bool = true;              // Ponese informaci o tom, zda je okno aktivnÌ
  FullScreen:bool = true;           // Ponese informaci o tom, zda je program ve fullscreenu
  rainbow: bool = true;             // Duhov˝ efekt?
  sp: bool;                         // Stisknut˝ mezernÌk?
  rp: bool;                         // Stisknut˝ enter?
  slowdown: GLfloat = 2.0;          // ZpomalenÌ Ë·stic
  xspeed, yspeed: GLfloat;          // Z·kladnÌ rychlost na os·ch
  zoom: GLfloat = -40.0;            // Zoom
  loop: gluint;                     // ÿÌdÌcÌ promÏnn· cykl˘
  col: gluint;                      // Vybran· barva
  delay: gluint;                    // ZpoûdÏnÌ pro duhov˝ efekt
  texture: array [0..0] of gluint;  // Ukl·d· texturu
  particle: array [0..MAX_PARTICLES-1] of particles;    // Pole Ë·stic
  colors: array [0..11,0..2] of glfloat = ((1.0,0.5,0.5),(1.0,0.75,0.5),(1.0,1.0,0.5),(0.75,1.0,0.5), // Barevn· paleta
                                           (0.5,1.0,0.5),(0.5,1.0,0.75),(0.5,1.0,1.0),(0.5,0.75,1.0),
                                           (0.5,0.5,1.0),(0.75,0.5,1.0),(1.0,0.5,1.0),(1.0,0.5,0.75));

function LoadBMP(FileName: pchar):PTAUX_RGBImageRec;        // Nahraje bitmapu
begin
  if Filename = '' then                                     // Byla p¯ed·na cesta k souboru?
    begin
    Result := nil;                                          // Pokud ne, konec
    exit;
    end;
  if not FileExists(Filename) then                          // Existuje soubor?
    begin
    Result := nil;                                          // Pokud ne, konec
    exit;
    end;
  Result := auxDIBImageLoadA(FileName);                     // NaËte bitmapu a vr·tÌ na ni ukazatel
end;

function LoadGLTextures: Bool;                              // Loading bitmapy a konverze na texturu
var TextureImage: array [0..0] of PTAUX_RGBImageRec;        // Ukl·d· bitmapu
    Status: Bool;                                           // Indikuje chyby
begin
  Status := false;
  ZeroMemory(@TextureImage,sizeof(TextureImage));           // Vynuluje pamÏù
  TextureImage[0] := LoadBMP('Data/Particle.bmp');          // Nahraje bitmapu
  if Assigned(TextureImage[0]) then                         // Vöe je bez problÈm˘?
    begin
    Status := true;                                         // Vöe je bez problÈm˘
    glGenTextures(1,Texture[0]);                            // Generuje texturu
    glBindTexture(GL_TEXTURE_2D,texture[0]);                // TypickÈ vytv·¯enÌ textury z bitmapy
    glTexImage2D(GL_TEXTURE_2D,0,3,TextureImage[0].sizeX,TextureImage[0].sizeY,0,GL_RGB,GL_UNSIGNED_BYTE,TextureImage[0].data);    // VlastnÌ vytv·¯enÌ textury
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);   // Filtrov·nÌ p¯i zvÏtöenÌ
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);   // Filtrov·nÌ p¯i zmenöenÌ
    end;
  Result := Status;                                         // Ozn·mÌ p¯ÌpadnÈ chyby
end;

procedure ReSizeGLScene(Width: GLsizei; Height: GLsizei); // ZmÏna velikosti a inicializace OpenGL okna
begin
  if (Height=0) then		                                  // ZabezpeËenÌ proti dÏlenÌ nulou
     Height:=1;                                           // NastavÌ v˝öku na jedna
  glViewport(0, 0, Width, Height);                        // Resetuje aktu·lnÌ nastavenÌ
  glMatrixMode(GL_PROJECTION);                            // ZvolÌ projekËnÌ matici
  glLoadIdentity();                                       // Reset matice
  gluPerspective(45.0,Width/Height,0.1,100.0);            // V˝poËet perspektivy
  glMatrixMode(GL_MODELVIEW);                             // ZvolÌ matici Modelview
  glLoadIdentity;                                         // Reset matice
end;


function InitGL:bool;	                              // Vöechno nastavenÌ OpenGL
begin
  if not LoadGLTextures then                        // Nahraje texturu
    begin
    Result := false;
    exit;
    end;
  glShadeModel(GL_SMOOTH);			                    // PovolÌ jemnÈ stÌnov·nÌ
  glClearColor(0.0, 0.0, 0.0, 0.0);	  	            // »ernÈ pozadÌ
  glClearDepth(1.0);				                        // NastavenÌ hloubkovÈho bufferu
  glDisable(GL_DEPTH_TEST);                         // Vypne hloubkovÈ testov·nÌ
  glEnable(GL_BLEND);                               // Zapne blending
  glBlendFunc(GL_SRC_ALPHA,GL_ONE);                 // Typ blendingu
  glHint(GL_PERSPECTIVE_CORRECTION_HINT,GL_NICEST); // Perspektiva
  glHint(GL_POINT_SMOOTH_HINT,GL_NICEST);           // Jemnost bod˘
  glEnable(GL_TEXTURE_2D);                          // Zapne mapov·nÌ textur
  glBindTexture(GL_TEXTURE_2D,texture[0]);          // Vybere texturu
  for loop:=0 to MAX_PARTICLES-1 do                 // Inicializace Ë·stic
    begin
    particle[loop].active := true;                                  // Aktivace
    particle[loop].life := 1.0;                                     // OûivenÌ
    particle[loop].fade := Random(100)/1000 + 0.003;                // Rychlost st·rnutÌ
    particle[loop].r := colors[Trunc(loop*(12/MAX_PARTICLES)),0];   // »erven·
    particle[loop].g := colors[Trunc(loop*(12/MAX_PARTICLES)),1];   // Zelen·
    particle[loop].b := colors[Trunc(loop*(12/MAX_PARTICLES)),2];   // Modr·
    particle[loop].xi := (random(50)-26.0)*10.0;                    // Rychlost a smÏr pohybu na ose x
    particle[loop].yi := (random(50)-25.0)*10.0;                    // Rychlost a smÏr pohybu na ose y
    particle[loop].zi := (random(50)-25.0)*10.0;                    // Rychlost a smÏr pohybu na ose z
    particle[loop].xg := 0.0;                                       // Gravitace na ose x
    particle[loop].yg := -0.8;                                      // Gravitace na ose y
    particle[loop].zg := 0.0;                                       // Gravitace na ose z
    end;
  Result:=true;                                     // Inicializace probÏhla v po¯·dku
end;

function DrawGLScene():bool;                            // Vykreslov·nÌ
var x,y,z: glfloat;
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);  // Smaûe obrazovku a hloubkov˝ buffer
  glLoadIdentity();	                                    // Reset matice
  for loop:=0 to MAX_PARTICLES-1 do                     // Cyklus proch·zÌ kaûdou Ë·stici
    begin
    if particle[loop].active then                       // Pokud je Ë·stice aktivnÌ
      begin
      x := particle[loop].x;                            // x pozice
      y := particle[loop].y;                            // y pozice
      z := particle[loop].z+zoom;                       // z pozice + zoom
      // Barva Ë·stice
      glColor4f(particle[loop].r,particle[loop].g,particle[loop].b,particle[loop].life);
      glBegin(GL_TRIANGLE_STRIP);                       // Vytvo¯Ì obdÈlnÌk pomocÌ triangle strip
        glTexCoord2d(1,1); glVertex3f(x+0.5,y+0.5,z);   // HornÌ prav˝
        glTexCoord2d(0,1); glVertex3f(x-0.5,y+0.5,z);   // HornÌ lev˝
        glTexCoord2d(1,0); glVertex3f(x+0.5,y-0.5,z);   // DolnÌ prav˝
        glTexCoord2d(0,0); glVertex3f(x-0.5,y-0.5,z);   // DolnÌ lev˝
      glEnd;                                            // UkonËÌ triangle strip
      particle[loop].x := particle[loop].x + particle[loop].xi/(slowdown*1000);   // Pohyb na ose x
      particle[loop].y := particle[loop].y + particle[loop].yi/(slowdown*1000);   // Pohyb na ose y
      particle[loop].z := particle[loop].z + particle[loop].zi/(slowdown*1000);   // Pohyb na ose z
      particle[loop].xi := particle[loop].xi + particle[loop].xg;                 // GravitaËnÌ p˘sobenÌ na ose x
      particle[loop].yi := particle[loop].yi + particle[loop].yg;                 // GravitaËnÌ p˘sobenÌ na ose y
      particle[loop].zi := particle[loop].zi + particle[loop].zg;                 // GravitaËnÌ p˘sobenÌ na ose z
      particle[loop].life := particle[loop].life - particle[loop].fade;           // SnÌûÌ ûivot o st·rnutÌ
      if (particle[loop].life < 0.0) then                         // Pokud zem¯ela
      begin
        particle[loop].life := 1.0;                               // Nov˝ ûivot
        particle[loop].fade := (random(100)/1000.0) + 0.003;      // N·hodnÈ st·rnutÌ
        particle[loop].x := 0.0;                                  // Vycentrov·nÌ doprost¯ed obrazovky
        particle[loop].y := 0.0;                                  // Vycentrov·nÌ doprost¯ed obrazovky
        particle[loop].z := 0.0;                                  // Vycentrov·nÌ doprost¯ed obrazovky
        particle[loop].xi := xspeed + (random(60) - 32.0);        // Nov· rychlost a smÏr
        particle[loop].yi := yspeed + (random(60) - 30.0);        // Nov· rychlost a smÏr
        particle[loop].zi := (random(60) - 30.0);                 // Nov· rychlost a smÏr
        particle[loop].r := colors[col, 0];                       // Vybere barvu z palety
        particle[loop].g := colors[col, 1];                       // Vybere barvu z palety
        particle[loop].b := colors[col, 2];                       // Vybere barvu z palety
      end;
      // Pokud je stisknuta 8 a y gravitace je menöÌ neû 1.5
      if (keys[VK_NUMPAD8] AND (particle[loop].yg < 1.5)) then particle[loop].yg := particle[loop].yg + 0.01;
      // Pokud je stisknuta 2 a y gravitace je menöÌ neû -1.5
      if (keys[VK_NUMPAD2] AND (particle[loop].yg > -1.5)) then particle[loop].yg := particle[loop].yg - 0.01;
      // Pokud je stisknuta 6 a x gravitace je menöÌ neû 1.5
      if (keys[VK_NUMPAD6] AND (particle[loop].xg < 1.5)) then particle[loop].xg := particle[loop].xg + 0.01;
      // Pokud je stisknuta 4 a x gravitace je menöÌ neû -1.5
      if (keys[VK_NUMPAD4] AND (particle[loop].xg > -1.5)) then particle[loop].xg := particle[loop].xg - 0.01;
      if (keys[VK_TAB]) then                                      // Zp˘sobÌ v˝buch
      begin
        particle[loop].x := 0.0;                                  // Vycentrov·nÌ na st¯ed obrazovky
        particle[loop].y := 0.0;                                  // Vycentrov·nÌ na st¯ed obrazovky
        particle[loop].z := 0.0;                                  // Vycentrov·nÌ na st¯ed obrazovky
        particle[loop].xi := (random(50)-26.0)*10.0;              // N·hodn· rychlost
        particle[loop].yi := (random(50)-25.0)*10.0;              // N·hodn· rychlost
        particle[loop].zi := (random(50)-25.0)*10.0;              // N·hodn· rychlost
      end;
      end;
    end;
  Result := true;                                       // VykreslenÌ probÏhlo v po¯·dku
end;


function WndProc(hWnd: HWND;                            // Handle okna
                 message: UINT;                         // Zpr·va pro okno
                 wParam: WPARAM;                        // DoplÚkovÈ informace
                 lParam: LPARAM):                       // DoplÚkovÈ informace
                                  LRESULT; stdcall;
begin
  if message=WM_SYSCOMMAND then                         // SystÈmov˝ p¯Ìkaz
    begin
      case wParam of                                    // Typ systÈmovÈho p¯Ìkazu
        SC_SCREENSAVE,SC_MONITORPOWER:                  // Pokus o zapnutÌ öet¯iËe obrazovky, Pokus o p¯echod do ˙spornÈho reûimu?
          begin
            result:=0;                                  // Zabr·nÌ obojÌmu
            exit;
          end;
      end;
    end;
  case message of                                       // VÏtvenÌ podle p¯ÌchozÌ zpr·vy
    WM_ACTIVATE:                                        // ZmÏna aktivity okna
      begin
        if (Hiword(wParam)=0) then                      // Zkontroluje zda nenÌ minimalizovanÈ
          active:=true                                  // Program je aktivnÌ
        else
          active:=false;                                // Program nenÌ aktivnÌ
        Result:=0;                                      // N·vrat do hlavnÌho cyklu programu
      end;
    WM_CLOSE:                                           // Povel k ukonËenÌ programu
      Begin
        PostQuitMessage(0);                             // Poöle zpr·vu o ukonËenÌ
        result:=0                                       // N·vrat do hlavnÌho cyklu programu
      end;
    WM_KEYDOWN:                                         // Stisk kl·vesy
      begin
        keys[wParam] := TRUE;                           // Ozn·mÌ to programu
        result:=0;                                      // N·vrat do hlavnÌho cyklu programu
      end;
    WM_KEYUP:                                           // UvolnÏnÌ kl·vesy
      begin
    	keys[wParam] := FALSE;                            // Ozn·mÌ to programu
        result:=0;                                      // N·vrat do hlavnÌho cyklu programu
      end;
    WM_SIZe:                                            // ZmÏna velikosti okna
      begin
    	ReSizeGLScene(LOWORD(lParam),HIWORD(lParam));     // LoWord=äÌ¯ka, HiWord=V˝öka
        result:=0;                                      // N·vrat do hlavnÌho cyklu programu
      end
    else
      // P¯ed·nÌ ostatnÌch zpr·v systÈmu
      begin
      	Result := DefWindowProc(hWnd, message, wParam, lParam);
      end;
    end;
end;


procedure KillGLWindow;                                 // ZavÌr·nÌ okna
begin
  if FullScreen then                                    // Jsme ve fullscreenu?
    begin
      ChangeDisplaySettings(devmode(nil^),0);           // P¯epnutÌ do systÈmu
      showcursor(true);                                 // ZobrazÌ kurzor myöi
    end;
  if h_rc<> 0 then                                      // M·me rendering kontext?
    begin
      if (not wglMakeCurrent(h_Dc,0)) then              // Jsme schopni oddÏlit kontexty?
        MessageBox(0,'Release of DC and RC failed.',' Shutdown Error',MB_OK or MB_ICONERROR);
      if (not wglDeleteContext(h_Rc)) then              // Jsme schopni smazat RC?
        begin
          MessageBox(0,'Release of Rendering Context failed.',' Shutdown Error',MB_OK or MB_ICONERROR);
          h_Rc:=0;                                      // NastavÌ hRC na 0
        end;
    end;
  if (h_Dc=1) and (releaseDC(h_Wnd,h_Dc)<>0) then       // Jsme schopni uvolnit DC
    begin
      MessageBox(0,'Release of Device Context failed.',' Shutdown Error',MB_OK or MB_ICONERROR);
      h_Dc:=0;                                          // NastavÌ hDC na 0
    end;
  if (h_Wnd<>0) and (not destroywindow(h_Wnd))then      // Jsme schopni odstranit okno?
    begin
      MessageBox(0,'Could not release hWnd.',' Shutdown Error',MB_OK or MB_ICONERROR);
      h_Wnd:=0;                                         // NastavÌ hWnd na 0
    end;
  if (not UnregisterClass('OpenGL',hInstance)) then     // Jsme schopni odregistrovat t¯Ìdu okna?
    begin
      MessageBox(0,'Could Not Unregister Class.','SHUTDOWN ERROR',MB_OK or MB_ICONINFORMATION);
    end;
end;


function CreateGlWindow(title:Pchar; width,height,bits:integer;FullScreenflag:bool):boolean stdcall;
var
  Pixelformat: GLuint;            // Ukl·d· form·t pixel˘
  wc:TWndclass;                   // Struktura Windows Class
  dwExStyle:dword;                // RozöÌ¯en˝ styl okna
  dwStyle:dword;                  // Styl okna
  pfd: pixelformatdescriptor;     // NastavenÌ form·tu pixel˘
  dmScreenSettings: Devmode;      // MÛd za¯ÌzenÌ
  h_Instance:hinst;               // Instance okna
  WindowRect: TRect;              // ObdÈlnÌk okna
begin
  WindowRect.Left := 0;                               // NastavÌ lev˝ okraj na nulu
  WindowRect.Top := 0;                                // NastavÌ hornÌ okraj na nulu
  WindowRect.Right := width;                          // NastavÌ prav˝ okraj na zadanou hodnotu
  WindowRect.Bottom := height;                        // NastavÌ spodnÌ okraj na zadanou hodnotu
  h_instance:=GetModuleHandle(nil);                   // ZÌsk· instanci okna
  FullScreen:=FullScreenflag;                         // NastavÌ promÏnnou fullscreen na spr·vnou hodnotu
  with wc do
    begin
      style:=CS_HREDRAW or CS_VREDRAW or CS_OWNDC;    // P¯ekreslenÌ p¯i zmÏnÏ velikosti a vlastnÌ DC
      lpfnWndProc:=@WndProc;                          // Definuje proceduru okna
      cbClsExtra:=0;                                  // é·dn· extra data
      cbWndExtra:=0;                                  // é·dn· extra data
      hInstance:=h_Instance;                          // Instance
      hIcon:=LoadIcon(0,IDI_WINLOGO);                 // StandardnÌ ikona
      hCursor:=LoadCursor(0,IDC_ARROW);               // StandardnÌ kurzor myöi
      hbrBackground:=0;                               // PozadÌ nenÌ nutnÈ
      lpszMenuName:=nil;                              // Nechceme menu
      lpszClassName:='OpenGl';                        // JmÈno t¯Ìdy okna
    end;
  if  RegisterClass(wc)=0 then                        // Registruje t¯Ìdu okna
    begin
      MessageBox(0,'Failed To Register The Window Class.','Error',MB_OK or MB_ICONERROR);
      Result:=false;                                  // P¯i chybÏ vr·tÌ false
      exit;
    end;
  if FullScreen then                                  // Budeme ve fullscreenu?
    begin
      ZeroMemory( @dmScreenSettings, sizeof(dmScreenSettings) );  // Vynulov·nÌ pamÏti
      with dmScreensettings do
        begin
          dmSize := sizeof(dmScreenSettings);         // Velikost struktury Devmode
          dmPelsWidth  := width;	                    // äÌ¯ka okna
	        dmPelsHeight := height;                     // V˝öka okna
          dmBitsPerPel := bits;                       // Barevn· hloubka
          dmFields     := DM_BITSPERPEL or DM_PELSWIDTH or DM_PELSHEIGHT;
        end;
      // PokusÌ se pouûÌt pr·vÏ definovanÈ nastavenÌ
      if (ChangeDisplaySettings(dmScreenSettings, CDS_FULLSCREEN))<>DISP_CHANGE_SUCCESSFUL THEN
        Begin
          // Nejde-li fullscreen, m˘ûe uûivatel spustit program v oknÏ nebo ho opustit
          if MessageBox(0,'This FullScreen Mode Is Not Supported. Use Windowed Mode Instead?'
                                             ,'NeHe GL',MB_YESNO or MB_ICONEXCLAMATION)= IDYES then
                FullScreen:=false                     // BÏh v oknÏ
          else
            begin
              // ZobrazÌ uûivateli zpr·vu, ûe program bude ukonËen
              MessageBox(0,'Program Will Now Close.','Error',MB_OK or MB_ICONERROR);
              Result:=false;                          // Vr·tÌ FALSE
              exit;
            end;
          end;
    end;
  if FullScreen then                                  // Jsme st·le ve fullscreenu?
    begin
      dwExStyle:=WS_EX_APPWINDOW;                     // RozöÌ¯en˝ styl okna
      dwStyle:=WS_POPUP or WS_CLIPSIBLINGS or WS_CLIPCHILDREN; // Styl okna
      Showcursor(false);                              // Skryje kurzor
    end
  else
    begin
      dwExStyle:=WS_EX_APPWINDOW or WS_EX_WINDOWEDGE;   // RozöÌ¯en˝ styl okna
      dwStyle:=WS_OVERLAPPEDWINDOW or WS_CLIPSIBLINGS or WS_CLIPCHILDREN; // Styl okna
    end;
  AdjustWindowRectEx(WindowRect,dwStyle,false,dwExStyle); // P¯izp˘sobenÌ velikosti okna
  // Vytvo¯enÌ okna
  H_wnd:=CreateWindowEx(dwExStyle,                    // RozöÌ¯en˝ styl
                               'OpenGl',              // JmÈno t¯Ìdy
                               Title,                 // Titulek
                               dwStyle,               // Definovan˝ styl
                               0,0,                   // Pozice
                               WindowRect.Right-WindowRect.Left,  // V˝poËet öÌ¯ky
                               WindowRect.Bottom-WindowRect.Top,  // V˝poËet v˝öky
                               0,                     // é·dnÈ rodiËovskÈ okno
                               0,                     // Bez menu
                               hinstance,             // Instance
                               nil);                  // Nep¯edat nic do WM_CREATE
  if h_Wnd=0 then                                     // Pokud se okno nepoda¯ilo vytvo¯it
    begin
      KillGlWindow();                                 // ZruöÌ okno
      MessageBox(0,'Window creation error.','Error',MB_OK or MB_ICONEXCLAMATION);
      Result:=false;                                  // Vr·tÌ chybu
      exit;
    end;
  with pfd do                                         // Ozn·mÌme Windows jak chceme vöe nastavit
    begin
      nSize:= SizeOf( PIXELFORMATDESCRIPTOR );        // Velikost struktury
      nVersion:= 1;                                   // »Ìslo verze
      dwFlags:= PFD_DRAW_TO_WINDOW                    // Podpora okna
        or PFD_SUPPORT_OPENGL                         // Podpora OpenGL
        or PFD_DOUBLEBUFFER;                          // Podpora Double Bufferingu
      iPixelType:= PFD_TYPE_RGBA;                     // RGBA Format
      cColorBits:= bits;                              // ZvolÌ barevnou hloubku
      cRedBits:= 0;                                   // Bity barev ignorov·ny
      cRedShift:= 0;
      cGreenBits:= 0;
      cBlueBits:= 0;
      cBlueShift:= 0;
      cAlphaBits:= 0;                                 // é·dn˝ alpha buffer
      cAlphaShift:= 0;                                // Ignorov·n Shift bit
      cAccumBits:= 0;                                 // é·dn˝ akumulaËnÌ buffer
      cAccumRedBits:= 0;                              // AkumulaËnÌ bity ignorov·ny
      cAccumGreenBits:= 0;
      cAccumBlueBits:= 0;
      cAccumAlphaBits:= 0;
      cDepthBits:= 16;                                // 16-bitov˝ hloubkov˝ buffer (Z-Buffer)
      cStencilBits:= 0;                               // é·dn˝ Stencil Buffer
      cAuxBuffers:= 0;                                // é·dn˝ Auxiliary Buffer
      iLayerType:= PFD_MAIN_PLANE;                    // HlavnÌ vykreslovacÌ vrstva
      bReserved:= 0;                                  // Rezervov·no
      dwLayerMask:= 0;                                // Maska vrstvy ignorov·na
      dwVisibleMask:= 0;
      dwDamageMask:= 0;
    end;
  h_Dc := GetDC(h_Wnd);                               // ZkusÌ p¯ipojit kontext za¯ÌzenÌ
  if h_Dc=0 then                                      // Poda¯ilo se p¯ipojit kontext za¯ÌzenÌ?
    begin
      KillGLWindow();                                 // Zav¯e okno
      MessageBox(0,'Cant''t create a GL device context.','Error',MB_OK or MB_ICONEXCLAMATION);
      Result:=false;                                  // UkonËÌ program
      exit;
    end;
  PixelFormat := ChoosePixelFormat(h_Dc, @pfd);       // ZkusÌ najÌt Pixel Format
  if (PixelFormat=0) then                             // Poda¯ilo se najÌt Pixel Format?
    begin
      KillGLWindow();                                 // Zav¯e okno
      MessageBox(0,'Cant''t Find A Suitable PixelFormat.','Error',MB_OK or MB_ICONEXCLAMATION);
      Result:=false;                                  // UkonËÌ program
      exit;
    end;
  if (not SetPixelFormat(h_Dc,PixelFormat,@pfd)) then  // Poda¯ilo se nastavit Pixel Format?
    begin
      KillGLWindow();                                 // Zav¯e okno
      MessageBox(0,'Cant''t set PixelFormat.','Error',MB_OK or MB_ICONEXCLAMATION);
      Result:=false;                                  // UkonËÌ program
      exit;
    end;
  h_Rc := wglCreateContext(h_Dc);                     // Poda¯ilo se vytvo¯it Rendering Context?
  if (h_Rc=0) then
    begin
      KillGLWindow();                                 // Zav¯e okno
      MessageBox(0,'Cant''t create a GL rendering context.','Error',MB_OK or MB_ICONEXCLAMATION);
      Result:=false;                                  // UkonËÌ program
      exit;
    end;
  if (not wglMakeCurrent(h_Dc, h_Rc)) then            // Poda¯ilo se aktivovat Rendering Context?
    begin
      KillGLWindow();                                 // Zav¯e okno
      MessageBox(0,'Cant''t activate the GL rendering context.','Error',MB_OK or MB_ICONEXCLAMATION);
      Result:=false;                                  // UkonËÌ program
      exit;
    end;
  ShowWindow(h_Wnd,SW_SHOW);                          // ZobrazenÌ okna
  SetForegroundWindow(h_Wnd);                         // Do pop¯edÌ
  SetFOcus(h_Wnd);                                    // ZamÏ¯Ì fokus
  ReSizeGLScene(width,height);                        // NastavenÌ perspektivy OpenGL scÈny
  if (not InitGl()) then                              // Inicializace okna
    begin
      KillGLWindow();                                 // Zav¯e okno
      MessageBox(0,'initialization failed.','Error',MB_OK or MB_ICONEXCLAMATION);
      Result:=false;                                  // UkonËÌ program
      exit;
    end;
  Result:=true;                                       // Vöe probÏhlo v po¯·dku
end;


function WinMain(hInstance: HINST;                    // Instance
		 hPrevInstance: HINST;                            // P¯edchozÌ instance
		 lpCmdLine: PChar;                                // Parametry p¯ÌkazovÈ ¯·dky
		 nCmdShow: integer):                              // Stav zobrazenÌ okna
                        integer; stdcall;
var
  msg: TMsg;                                          // Struktura zpr·v systÈmu
  done: Bool;                                         // PromÏnn· pro ukonËenÌ programu

begin
  done:=false;
  // Dotaz na uûivatele pro fullscreen/okno
  if MessageBox(0,'Would You Like To Run In FullScreen Mode?','Start FullScreen',
                             MB_YESNO or MB_ICONQUESTION)=IDNO then
    FullScreen:=false                                 // BÏh v oknÏ
  else
    FullScreen:=true;                                 // Fullscreen
  if not CreateGLWindow('NeHe''s OpenGL Framework',640,480,16,FullScreen) then // Vytvo¯enÌ OpenGL okna
    begin
      Result := 0;                                    // Konec programu p¯i chybÏ
      exit;
    end;
  if FullScreen then slowdown := 1.0;                 // Zrychlit ve fullscreenu
  while not done do                                   // HlavnÌ cyklus programu
    begin
      if (PeekMessage(msg, 0, 0, 0, PM_REMOVE)) then  // P¯iöla zpr·va?
        begin
          if msg.message=WM_QUIT then                 // Obdrûeli jsme zpr·vu pro ukonËenÌ?
            done:=true                                // Konec programu
          else
            begin
	          TranslateMessage(msg);                    // P¯eloûÌ zpr·vu
	          DispatchMessage(msg);                     // Odeöle zpr·vu
	        end;
        end
      else      // Pokud nedoöla û·dn· zpr·va
        begin
          // Je program aktivnÌ, ale nelze kreslit? Byl stisknut ESC?
          if (active and not(DrawGLScene()) or keys[VK_ESCAPE]) then
            done:=true                                // UkonËÌme program
          else                                        // P¯ekreslenÌ scÈny
            SwapBuffers(h_Dc);                        // ProhozenÌ buffer˘ (Double Buffering)
          if keys[VK_F1] then                         // Byla stisknuta kl·vesa F1?
            begin
            Keys[VK_F1] := false;                     // OznaË ji jako nestisknutou
            KillGLWindow();                           // ZruöÌ okno
            FullScreen := not FullScreen;             // Negace fullscreen
            // Znovuvytvo¯enÌ okna
            if not CreateGLWindow('NeHe''s OpenGL Framework',640,480,16,fullscreen) then
              Result := 0;                            // Konec programu pokud nebylo vytvo¯eno
            end;
          if (keys[VK_ADD] and (slowdown > 1.0)) then slowdown := slowdown - 0.01;		  // UrychlenÌ Ë·stic
          if (keys[VK_SUBTRACT] and (slowdown < 4.0)) then slowdown := slowdown + 0.01;	// ZpomalenÌ Ë·stic
          if (keys[VK_PRIOR]) then zoom := zoom + 0.1;                                  // P¯iblÌûenÌ pohledu
          if (keys[VK_NEXT]) then zoom := zoom - 0.1;                                   // Odd·lenÌ pohledu
          if (keys[VK_RETURN] and not(rp)) then                                         // Stisk enteru
            begin
            rp := true;                                                                 // NastavÌ p¯Ìznak
            rainbow := not(rainbow);                                                    // Zapne/vypne duhov˝ efekt
            end;
          if (not(keys[VK_RETURN])) then rp := false;                                   // Po uvolnÏnÌ vypne p¯Ìznak
          if ((keys[ord(' ')] and not(sp)) or (rainbow and (delay > 25))) then          // MezernÌk nebo duhov˝ efekt
            begin
            if (keys[ord(' ')]) then rainbow := false;                                  // Pokud je stisknut vypne se duhov˝ mÛd
            sp := true;                                                                 // Ozn·mÌ programu, ûe byl stisknut mezernÌk
            delay := 0;                                                                 // Resetuje zpoûdÏnÌ duhov˝ch barev
            col := col + 1;                                                             // ZmÏnÌ barvu Ë·stice
            if (col > 11) then col := 0;                                                // Proti p¯eteËenÌ pole
            end;
          if (not(keys[ord(' ')])) then sp := false;                                    // UvolnÏnÌ mezernÌku
          if (keys[VK_UP] and (yspeed < 200)) then yspeed := yspeed + 1.0;              // äipka nahoru
          if (keys[VK_DOWN] and (yspeed > -200)) then yspeed := yspeed - 1.0;           // äipka dol˘
          if (keys[VK_RIGHT] and (xspeed < 200)) then xspeed := xspeed + 1.0;           // äipka doprava
          if (keys[VK_LEFT] and (xspeed > -200)) then xspeed := xspeed - 1.0;           // äipka doleva
          delay := delay + 1;                                                           // Inkrementace zpoûdÏnÌ duhovÈho efektu
        end;
    end;                                              // Konec smyËky while
  killGLwindow();                                     // Zav¯e okno
  result:=msg.wParam;                                 // UkonËenÌ programu
end;

begin
  WinMain( hInstance, hPrevInst, CmdLine, CmdShow );   // Start programu
end.

